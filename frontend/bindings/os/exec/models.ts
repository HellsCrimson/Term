// Cynhyrchwyd y ffeil hon yn awtomatig. PEIDIWCH Â MODIWL
// This file is automatically generated. DO NOT EDIT

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import { Create as $Create } from "@wailsio/runtime";

// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as io$0 from "../../io/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as os$0 from "../models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as syscall$0 from "../../syscall/models.js";
// eslint-disable-next-line @typescript-eslint/ban-ts-comment
// @ts-ignore: Unused imports
import * as time$0 from "../../time/models.js";

/**
 * Cmd represents an external command being prepared or run.
 * 
 * A Cmd cannot be reused after calling its [Cmd.Run], [Cmd.Output] or [Cmd.CombinedOutput]
 * methods.
 */
export class Cmd {
    /**
     * Path is the path of the command to run.
     * 
     * This is the only field that must be set to a non-zero
     * value. If Path is relative, it is evaluated relative
     * to Dir.
     */
    "Path": string;

    /**
     * Args holds command line arguments, including the command as Args[0].
     * If the Args field is empty or nil, Run uses {Path}.
     * 
     * In typical use, both Path and Args are set by calling Command.
     */
    "Args": string[];

    /**
     * Env specifies the environment of the process.
     * Each entry is of the form "key=value".
     * If Env is nil, the new process uses the current process's
     * environment.
     * If Env contains duplicate environment keys, only the last
     * value in the slice for each duplicate key is used.
     * As a special case on Windows, SYSTEMROOT is always added if
     * missing and not explicitly set to the empty string.
     * 
     * See also the Dir field, which may set PWD in the environment.
     */
    "Env": string[];

    /**
     * Dir specifies the working directory of the command.
     * If Dir is the empty string, Run runs the command in the
     * calling process's current directory.
     * 
     * On Unix systems, the value of Dir also determines the
     * child process's PWD environment variable if not otherwise
     * specified. A Unix process represents its working directory
     * not by name but as an implicit reference to a node in the
     * file tree. So, if the child process obtains its working
     * directory by calling a function such as C's getcwd, which
     * computes the canonical name by walking up the file tree, it
     * will not recover the original value of Dir if that value
     * was an alias involving symbolic links. However, if the
     * child process calls Go's [os.Getwd] or GNU C's
     * get_current_dir_name, and the value of PWD is an alias for
     * the current directory, those functions will return the
     * value of PWD, which matches the value of Dir.
     */
    "Dir": string;

    /**
     * Stdin specifies the process's standard input.
     * 
     * If Stdin is nil, the process reads from the null device (os.DevNull).
     * 
     * If Stdin is an *os.File, the process's standard input is connected
     * directly to that file.
     * 
     * Otherwise, during the execution of the command a separate
     * goroutine reads from Stdin and delivers that data to the command
     * over a pipe. In this case, Wait does not complete until the goroutine
     * stops copying, either because it has reached the end of Stdin
     * (EOF or a read error), or because writing to the pipe returned an error,
     * or because a nonzero WaitDelay was set and expired.
     */
    "Stdin": io$0.Reader;

    /**
     * Stdout and Stderr specify the process's standard output and error.
     * 
     * If either is nil, Run connects the corresponding file descriptor
     * to the null device (os.DevNull).
     * 
     * If either is an *os.File, the corresponding output from the process
     * is connected directly to that file.
     * 
     * Otherwise, during the execution of the command a separate goroutine
     * reads from the process over a pipe and delivers that data to the
     * corresponding Writer. In this case, Wait does not complete until the
     * goroutine reaches EOF or encounters an error or a nonzero WaitDelay
     * expires.
     * 
     * If Stdout and Stderr are the same writer, and have a type that can
     * be compared with ==, at most one goroutine at a time will call Write.
     */
    "Stdout": io$0.Writer;
    "Stderr": io$0.Writer;

    /**
     * ExtraFiles specifies additional open files to be inherited by the
     * new process. It does not include standard input, standard output, or
     * standard error. If non-nil, entry i becomes file descriptor 3+i.
     * 
     * ExtraFiles is not supported on Windows.
     */
    "ExtraFiles": (os$0.File | null)[];

    /**
     * SysProcAttr holds optional, operating system-specific attributes.
     * Run passes it to os.StartProcess as the os.ProcAttr's Sys field.
     */
    "SysProcAttr": syscall$0.SysProcAttr | null;

    /**
     * Process is the underlying process, once started.
     */
    "Process": os$0.Process | null;

    /**
     * ProcessState contains information about an exited process.
     * If the process was started successfully, Wait or Run will
     * populate its ProcessState when the command completes.
     */
    "ProcessState": os$0.ProcessState | null;

    /**
     * LookPath error, if any.
     */
    "Err": any;

    /**
     * If Cancel is non-nil, the command must have been created with
     * CommandContext and Cancel will be called when the command's
     * Context is done. By default, CommandContext sets Cancel to
     * call the Kill method on the command's Process.
     * 
     * Typically a custom Cancel will send a signal to the command's
     * Process, but it may instead take other actions to initiate cancellation,
     * such as closing a stdin or stdout pipe or sending a shutdown request on a
     * network socket.
     * 
     * If the command exits with a success status after Cancel is
     * called, and Cancel does not return an error equivalent to
     * os.ErrProcessDone, then Wait and similar methods will return a non-nil
     * error: either an error wrapping the one returned by Cancel,
     * or the error from the Context.
     * (If the command exits with a non-success status, or Cancel
     * returns an error that wraps os.ErrProcessDone, Wait and similar methods
     * continue to return the command's usual exit status.)
     * 
     * If Cancel is set to nil, nothing will happen immediately when the command's
     * Context is done, but a nonzero WaitDelay will still take effect. That may
     * be useful, for example, to work around deadlocks in commands that do not
     * support shutdown signals but are expected to always finish quickly.
     * 
     * Cancel will not be called if Start returns a non-nil error.
     */
    "Cancel": any;

    /**
     * If WaitDelay is non-zero, it bounds the time spent waiting on two sources
     * of unexpected delay in Wait: a child process that fails to exit after the
     * associated Context is canceled, and a child process that exits but leaves
     * its I/O pipes unclosed.
     * 
     * The WaitDelay timer starts when either the associated Context is done or a
     * call to Wait observes that the child process has exited, whichever occurs
     * first. When the delay has elapsed, the command shuts down the child process
     * and/or its I/O pipes.
     * 
     * If the child process has failed to exit — perhaps because it ignored or
     * failed to receive a shutdown signal from a Cancel function, or because no
     * Cancel function was set — then it will be terminated using os.Process.Kill.
     * 
     * Then, if the I/O pipes communicating with the child process are still open,
     * those pipes are closed in order to unblock any goroutines currently blocked
     * on Read or Write calls.
     * 
     * If pipes are closed due to WaitDelay, no Cancel call has occurred,
     * and the command has otherwise exited with a successful status, Wait and
     * similar methods will return ErrWaitDelay instead of nil.
     * 
     * If WaitDelay is zero (the default), I/O pipes will be read until EOF,
     * which might not occur until orphaned subprocesses of the command have
     * also closed their descriptors for the pipes.
     */
    "WaitDelay": time$0.Duration;

    /** Creates a new Cmd instance. */
    constructor($$source: Partial<Cmd> = {}) {
        if (!("Path" in $$source)) {
            this["Path"] = "";
        }
        if (!("Args" in $$source)) {
            this["Args"] = [];
        }
        if (!("Env" in $$source)) {
            this["Env"] = [];
        }
        if (!("Dir" in $$source)) {
            this["Dir"] = "";
        }
        if (!("Stdin" in $$source)) {
            this["Stdin"] = null;
        }
        if (!("Stdout" in $$source)) {
            this["Stdout"] = null;
        }
        if (!("Stderr" in $$source)) {
            this["Stderr"] = null;
        }
        if (!("ExtraFiles" in $$source)) {
            this["ExtraFiles"] = [];
        }
        if (!("SysProcAttr" in $$source)) {
            this["SysProcAttr"] = null;
        }
        if (!("Process" in $$source)) {
            this["Process"] = null;
        }
        if (!("ProcessState" in $$source)) {
            this["ProcessState"] = null;
        }
        if (!("Err" in $$source)) {
            this["Err"] = null;
        }
        if (!("Cancel" in $$source)) {
            this["Cancel"] = null;
        }
        if (!("WaitDelay" in $$source)) {
            this["WaitDelay"] = time$0.Duration.$zero;
        }

        Object.assign(this, $$source);
    }

    /**
     * Creates a new Cmd instance from a string or object.
     */
    static createFrom($$source: any = {}): Cmd {
        const $$createField1_0 = $$createType0;
        const $$createField2_0 = $$createType0;
        const $$createField7_0 = $$createType3;
        const $$createField8_0 = $$createType5;
        const $$createField9_0 = $$createType7;
        const $$createField10_0 = $$createType9;
        let $$parsedSource = typeof $$source === 'string' ? JSON.parse($$source) : $$source;
        if ("Args" in $$parsedSource) {
            $$parsedSource["Args"] = $$createField1_0($$parsedSource["Args"]);
        }
        if ("Env" in $$parsedSource) {
            $$parsedSource["Env"] = $$createField2_0($$parsedSource["Env"]);
        }
        if ("ExtraFiles" in $$parsedSource) {
            $$parsedSource["ExtraFiles"] = $$createField7_0($$parsedSource["ExtraFiles"]);
        }
        if ("SysProcAttr" in $$parsedSource) {
            $$parsedSource["SysProcAttr"] = $$createField8_0($$parsedSource["SysProcAttr"]);
        }
        if ("Process" in $$parsedSource) {
            $$parsedSource["Process"] = $$createField9_0($$parsedSource["Process"]);
        }
        if ("ProcessState" in $$parsedSource) {
            $$parsedSource["ProcessState"] = $$createField10_0($$parsedSource["ProcessState"]);
        }
        return new Cmd($$parsedSource as Partial<Cmd>);
    }
}

// Private type creation functions
const $$createType0 = $Create.Array($Create.Any);
const $$createType1 = os$0.File.createFrom;
const $$createType2 = $Create.Nullable($$createType1);
const $$createType3 = $Create.Array($$createType2);
const $$createType4 = syscall$0.SysProcAttr.createFrom;
const $$createType5 = $Create.Nullable($$createType4);
const $$createType6 = os$0.Process.createFrom;
const $$createType7 = $Create.Nullable($$createType6);
const $$createType8 = os$0.ProcessState.createFrom;
const $$createType9 = $Create.Nullable($$createType8);
